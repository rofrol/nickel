//! Define the main evaluation stack of the Nickel abstract machine and related operations.
//!
//! See [eval](../eval/index.html).
use crate::eval::{Closure, Environment, IdentKind, StdThunkData, Thunk, ThunkUpdateFrame};
use crate::operation::OperationCont;
use crate::position::TermPos;
use crate::term::{RichTerm, StrChunk};

/// An element of the stack.
pub enum Marker {
    /// An equality to test.
    ///
    /// When evaluating one equality `t1 == t2`, the abstract machine may generate several new
    /// equalities to test (for example, take `t1` and `t2` to be `[1, 2, 3]`). In this case, the
    /// first equality is evaluated and the remaining ones - the continuation of the whole
    /// computation - are put on the stack as `Eq` elements. If an equality evaluates to `false` at
    /// some point, all the consecutive `Eq` elements at the top of the stack are discarded.
    Eq(Closure, Closure),
    /// An argument of an application.
    Arg(Closure, TermPos),
    /// A tracked argument. Behave the same as a standard argument, but is given directly as a thunk, such that
    /// it can be shared with other part of the program.
    ///
    /// In particular, contract arguments are tracked, in order to report the actual, evaluated offending term in case of blame.
    TrackedArg(Thunk, TermPos),
    /// A thunk, which is pointer to a mutable memory cell to be updated.
    Thunk(ThunkUpdateFrame<StdThunkData>),
    /// The continuation of a primitive operation.
    Cont(
        OperationCont,
        usize,   /*callStack size*/
        TermPos, /*position span of the operation*/
    ),
    /// A string chunk.
    ///
    /// Generated by `ChunksConcat` when evaluating a string with interpolated expressions. Such
    /// strings are represented by a list of chunks to evaluate and concatenate, a chunk being
    /// either an interpolated expression or a string literals. The shared environment is stored in
    /// the top element of the stack, which must be `StrAcc`.
    StrChunk(StrChunk<RichTerm>),
    /// A string accumulator. Used by `ChunksConcat` to store additional state, that is the string being
    /// constructed, the indentation of the chunk being evaluated, and the common initial environment of chunks.
    StrAcc(
        String,      /* the accumulator */
        usize,       /* the indentation level of the chunk currently evaluated */
        Environment, /* the common environment of chunks */
    ),
    Strictness(bool),
}

impl std::fmt::Debug for Marker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Marker::Eq(_, _) => write!(f, "Eq"),
            Marker::Arg(_, _) => write!(f, "Arg"),
            Marker::TrackedArg(_, _) => write!(f, "TrackedArg"),
            Marker::Thunk(_) => write!(f, "Thunk"),
            Marker::Cont(op, sz, _) => write!(f, "Cont {:?} (callstack size {})", op, sz),
            Marker::StrChunk(_) => write!(f, "StrChunk"),
            Marker::StrAcc(_, _, _) => write!(f, "StrAcc"),
            Marker::Strictness(s) => write!(f, "Strictness = {}", s),
        }
    }
}

impl Marker {
    pub fn is_arg(&self) -> bool {
        matches!(*self, Marker::Arg(..) | Marker::TrackedArg(..))
    }

    pub fn is_thunk(&self) -> bool {
        matches!(*self, Marker::Thunk(..))
    }

    pub fn is_cont(&self) -> bool {
        matches!(*self, Marker::Cont(..))
    }

    pub fn is_eq(&self) -> bool {
        matches!(*self, Marker::Eq(..))
    }

    pub fn is_str_chunk(&self) -> bool {
        matches!(*self, Marker::StrChunk(..))
    }

    pub fn is_str_acc(&self) -> bool {
        matches!(*self, Marker::StrAcc(..))
    }

    pub fn is_strictness(&self) -> bool {
        matches!(*self, Marker::Strictness(..))
    }
}

/// The evaluation stack.
pub struct Stack(Vec<Marker>);

impl IntoIterator for Stack {
    type Item = Marker;
    type IntoIter = ::std::vec::IntoIter<Marker>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

impl Stack {
    pub fn new() -> Stack {
        Stack(Vec::new())
    }

    /// Count the number of consecutive elements satisfying `pred` from the top of the stack.
    fn count<P>(&self, pred: P) -> usize
    where
        P: Fn(&Marker) -> bool,
    {
        let mut count = 0;
        for marker in self.0.iter().rev() {
            if pred(marker) {
                count += 1;
            } else {
                break;
            }
        }
        count
    }

    /// Count the number of arguments at the top of the stack.
    pub fn count_args(&self) -> usize {
        Stack::count(self, Marker::is_arg)
    }

    pub fn push_arg(&mut self, arg: Closure, pos: TermPos) {
        self.0.push(Marker::Arg(arg, pos))
    }

    pub fn push_tracked_arg(&mut self, arg_thunk: Thunk, pos: TermPos) {
        self.0.push(Marker::TrackedArg(arg_thunk, pos))
    }

    pub fn push_thunk(&mut self, thunk: ThunkUpdateFrame<StdThunkData>) {
        self.0.push(Marker::Thunk(thunk))
    }

    pub fn push_op_cont(&mut self, cont: OperationCont, len: usize, pos: TermPos) {
        self.0.push(Marker::Cont(cont, len, pos))
    }

    /// Push a sequence of equalities on the stack.
    pub fn push_eqs<I>(&mut self, it: I)
    where
        I: Iterator<Item = (Closure, Closure)>,
    {
        self.0.extend(it.map(|(t1, t2)| Marker::Eq(t1, t2)));
    }

    /// Push a sequence of string chunks on the stack.
    pub fn push_str_chunks<I>(&mut self, it: I)
    where
        I: Iterator<Item = StrChunk<RichTerm>>,
    {
        self.0.extend(it.map(Marker::StrChunk));
    }

    /// Push a string accumulator on the stack.
    pub fn push_str_acc(&mut self, acc: String, indent: usize, env: Environment) {
        self.0.push(Marker::StrAcc(acc, indent, env));
    }

    pub fn push_strictness(&mut self, strict: bool) {
        self.0.push(Marker::Strictness(strict));
    }

    /// Try to pop an argument from the top of the stack. If `None` is returned, the top element
    /// was not an argument and the stack is left unchanged.
    ///
    /// If the argument is tracked, it is automatically converted into an owned closure.
    pub fn pop_arg(&mut self) -> Option<(Closure, TermPos)> {
        match self.0.pop() {
            Some(Marker::Arg(arg, pos)) => Some((arg, pos)),
            Some(Marker::TrackedArg(arg_thunk, pos)) => Some((arg_thunk.into_closure(), pos)),
            Some(m) => {
                self.0.push(m);
                None
            }
            _ => None,
        }
    }

    /// Try to pop an argument from the top of the stack and return it as a thunk. If `None` is
    /// returned, the top element was not an argument and the stack is left unchanged.
    ///
    /// If the argument is not tracked, it is directly returned.
    pub fn pop_arg_as_thunk(&mut self) -> Option<(Thunk, TermPos)> {
        match self.0.pop() {
            Some(Marker::Arg(arg, pos)) => Some((Thunk::new(arg, IdentKind::Lam()), pos)),
            Some(Marker::TrackedArg(arg_thunk, pos)) => Some((arg_thunk, pos)),
            Some(m) => {
                self.0.push(m);
                None
            }
            _ => None,
        }
    }

    /// Try to pop a thunk from the top of the stack. If `None` is returned, the top element was
    /// not a thunk and the stack is left unchanged.
    pub fn pop_thunk(&mut self) -> Option<ThunkUpdateFrame<StdThunkData>> {
        match self.0.pop() {
            Some(Marker::Thunk(thunk)) => Some(thunk),
            Some(m) => {
                self.0.push(m);
                None
            }
            _ => None,
        }
    }

    /// Try to pop an operator continuation from the top of the stack. If `None` is returned, the
    /// top element was not an operator continuation and the stack is left unchanged.
    pub fn pop_op_cont(&mut self) -> Option<(OperationCont, usize, TermPos)> {
        match self.0.pop() {
            Some(Marker::Cont(cont, len, pos)) => Some((cont, len, pos)),
            Some(m) => {
                self.0.push(m);
                None
            }
            _ => None,
        }
    }

    /// Try to pop an equality from the top of the stack. If `None` is returned, the top element
    /// was not an equality and the stack is left unchanged.
    pub fn pop_eq(&mut self) -> Option<(Closure, Closure)> {
        if self.0.last().map(Marker::is_eq).unwrap_or(false) {
            match self.0.pop() {
                Some(Marker::Eq(c1, c2)) => Some((c1, c2)),
                _ => panic!(),
            }
        } else {
            None
        }
    }

    /// Try to pop the a string accumulator from the stack. If `None` is returned, the top element
    /// was not a string accumulator and the stack is left unchanged.
    pub fn pop_str_acc(&mut self) -> Option<(String, usize, Environment)> {
        if self.0.last().map(Marker::is_str_acc).unwrap_or(false) {
            match self.0.pop() {
                Some(Marker::StrAcc(acc, indent, env)) => Some((acc, indent, env)),
                _ => panic!(),
            }
        } else {
            None
        }
    }

    /// Try to pop a string chunk from the top of the stack. If `None` is returned, the top element
    /// was not a string chunk and the stack is left unchanged.
    pub fn pop_str_chunk(&mut self) -> Option<StrChunk<RichTerm>> {
        if self.0.last().map(Marker::is_str_chunk).unwrap_or(false) {
            match self.0.pop() {
                Some(Marker::StrChunk(c)) => Some(c),
                _ => panic!(),
            }
        } else {
            None
        }
    }

    pub fn pop_strictness_marker(&mut self) -> Option<bool> {
        if self.0.last().map(Marker::is_strictness).unwrap_or(false) {
            match self.0.pop() {
                Some(Marker::Strictness(s)) => Some(s),
                _ => panic!(),
            }
        } else {
            None
        }
    }

    /// Check if the top element is a thunk.
    pub fn is_top_thunk(&self) -> bool {
        self.0.last().map(Marker::is_thunk).unwrap_or(false)
    }

    /// Check if the top element is an operation continuation.
    pub fn is_top_cont(&self) -> bool {
        self.0.last().map(Marker::is_cont).unwrap_or(false)
    }

    /// Discard all the consecutive equality from the top of the stack. This drops the continuation
    /// of the equality being currently evaluated.
    pub fn clear_eqs(&mut self) {
        while self.pop_eq().is_some() {}
    }

    /// Turning the top element of the stack into a tracked arg if it was not already. Returns the
    /// corresponding thunk, or `None` if the top element wasn't an argument.
    pub fn track_arg(&mut self) -> Option<Thunk> {
        match self.0.last_mut() {
            Some(Marker::TrackedArg(thunk, _)) => Some(thunk.clone()),
            Some(Marker::Arg(..)) => {
                let (closure, pos) = self.pop_arg().unwrap();
                let thunk = Thunk::new(closure, IdentKind::Lam());
                self.push_tracked_arg(thunk.clone(), pos);
                Some(thunk)
            }
            _ => None,
        }
    }
}

impl std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "--- STACK ---\n")?;
        for marker in self.0.iter().rev() {
            write!(f, "| {:?}\n", marker)?;
        }
        write!(f, "---  END  ---\n")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::eval::{IdentKind, Thunk};
    use crate::term::{Term, UnaryOp};
    use assert_matches::assert_matches;

    impl Stack {
        /// Count the number of thunks at the top of the stack.
        pub fn count_thunks(&self) -> usize {
            Stack::count(self, Marker::is_thunk)
        }

        /// Count the number of operation continuation at the top of the stack.
        pub fn count_conts(&self) -> usize {
            Stack::count(self, Marker::is_cont)
        }
    }

    fn some_closure() -> Closure {
        Closure::atomic_closure(Term::Bool(true).into())
    }

    fn some_cont() -> OperationCont {
        OperationCont::Op1(UnaryOp::IsNum(), TermPos::None)
    }

    fn some_arg_marker() -> Marker {
        Marker::Arg(some_closure(), TermPos::None)
    }

    fn some_thunk_marker() -> Marker {
        let mut thunk = Thunk::new(some_closure(), IdentKind::Let());
        Marker::Thunk(thunk.mk_update_frame().unwrap())
    }

    fn some_cont_marker() -> Marker {
        Marker::Cont(some_cont(), 42, TermPos::None)
    }

    #[test]
    fn marker_differentiates() {
        assert!(some_arg_marker().is_arg());
        assert!(some_thunk_marker().is_thunk());
        assert!(some_cont_marker().is_cont());
    }

    #[test]
    fn pushing_and_popping_args() {
        let mut s = Stack::new();
        assert_eq!(0, s.count_args());

        s.push_arg(some_closure(), TermPos::None);
        s.push_arg(some_closure(), TermPos::None);
        assert_eq!(2, s.count_args());
        assert_eq!(some_closure(), s.pop_arg().expect("Already checked").0);
        assert_eq!(1, s.count_args());
    }

    #[test]
    fn pushing_and_popping_thunks() {
        let mut s = Stack::new();
        assert_eq!(0, s.count_thunks());

        let mut thunk = Thunk::new(some_closure(), IdentKind::Let());
        s.push_thunk(thunk.mk_update_frame().unwrap());
        thunk = Thunk::new(some_closure(), IdentKind::Let());
        s.push_thunk(thunk.mk_update_frame().unwrap());

        assert_eq!(2, s.count_thunks());
        s.pop_thunk().expect("Already checked");
        assert_eq!(1, s.count_thunks());
    }

    #[test]
    fn thunk_blackhole() {
        let mut thunk = Thunk::new(some_closure(), IdentKind::Let());
        let thunk_upd = thunk.mk_update_frame();
        assert_matches!(thunk_upd, Ok(..));
        assert_matches!(thunk.mk_update_frame(), Err(..));
        thunk_upd.unwrap().update(some_closure());
        assert_matches!(thunk.mk_update_frame(), Ok(..));
    }

    #[test]
    fn pushing_and_popping_conts() {
        let mut s = Stack::new();
        assert_eq!(0, s.count_conts());

        s.push_op_cont(some_cont(), 3, TermPos::None);
        s.push_op_cont(some_cont(), 4, TermPos::None);
        assert_eq!(2, s.count_conts());
        assert_eq!(
            (some_cont(), 4, TermPos::None),
            s.pop_op_cont().expect("Already checked")
        );
        assert_eq!(1, s.count_conts());
    }

    #[test]
    fn pushing_and_poping_strictness_markers() {
        let mut s = Stack::new();
        assert_eq!(0, s.count_args());

        s.push_strictness(true);
        assert_eq!(0, s.count_args());
        s.push_arg(some_closure(), TermPos::None);
        s.push_arg(some_closure(), TermPos::None);
        assert_eq!(2, s.count_args());
        s.push_strictness(false);
        assert_eq!(0, s.count_args());

        assert_eq!(s.pop_strictness_marker(), Some(false));
        assert_eq!(2, s.count_args());
        assert_matches!(s.pop_arg(), Some(..));
        assert_matches!(s.pop_arg(), Some(..));
        assert_eq!(s.pop_arg(), None);
        assert_eq!(0, s.count_args());
        assert_eq!(s.pop_strictness_marker(), Some(true));
        assert_eq!(0, s.count_args());
    }
}
